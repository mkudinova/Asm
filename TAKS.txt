Обязательные задачи в весеннем семестре 2021

Задача 1.А.
Дано: бинарное дерево поиска.

Надо: удалить элемент по значению.

Обязательно: отладить используя gdb.

Критически важно: менять именно структуру дерева - то, как одно иэементы ссылаются на другие. Ни в коем случае, не изменять данные внутри элементов. Решения, в которых потеряно соответствие между данными элемента дерева и выделенной под этот элемент областью памяти засчитываться не будут!

Полезно: при изменении дерева распечатывать его так, чтобы было видно его структуру. Например, с помощью обхода дерева в ШИРИНУ - см. https://github.com/mkudinova/2021-2022-MIPT/blob/main/2021-12-03-bin_tree.c

Удобно вместо удаляемого элемента подставлять самый правый (=максимальный) элемент его левого поддерева, или самый левый (=минимальный) элемент его правого поддерева.
Можете, если хотите, сделать так, чтобы каждый элемент хранил указатель и на своего родителя тоже.

Задача 1.Б.
Условие тоже самое. Но, нельзя хранить указатель на родительской элемент. И, реализация обязательно должна придерживаться следующего:

a) Будем удалять элемент следующим образом: (можете менять лево-право с точностью до симметрии)
 - если у него нет потомков - просто освобождаем память, и за'NULL'яем в его родительском элементе (parent) поле, ранее указывавщее на удаляемый элемент (хранившее его адрес) (это будет или parent->lv, или parent->pr, или root всего дерева в зависимости от того, какой элемент удаляем);
 - если у него нет левых потомков, но есть правые, то заменяем удаляемый элемент его правым потомком: в его родительском элементе, в поле, ранее указывавщее на удаляемый элемент, вписываем адрес его (удаляемого) правого потомка;
 - если у него есть левые потомки - т.е. левое поддерево, то на место удаляемого элемента ставим самый правый элемент его левого поддерева (т.е., максимальный среди его левых потомков, т.е., самый близкий к нему слева;):
 --- у такого элемента гарантировано не будет правых потомков, но могут быть левые, и записи в его родителе тоже надо будет исправить
 --- => если родитель (parent_of_new) самого правого элемента (new) из левого поддерева удаляемого элемента и есть сам удаляемый элемент (parent_of_new == del_elem),
 ------ то просто ставим самый правый на место удаляемого (т.е., на parent удаляемого теперь указывает (хранит в том же поле адрес) самого правого элемента левого поддерева удаляемого элемента; а самый правый оставляет своих старых левых потомков (правых у него не было) и должен теперь стать родителем для правых потомков удаляемого;
 --- если родитель (parent_of_new) самого правого элемента (new) из левого поддерева удаляемого элемента и НЕ сам удаляемый элемент (parent_of_new != del_elem),
 ------ то parent_of_new должен получить себе всех левых потомков этого new, в качестве правого поддерева (parent_of_new->pr = parent_of_new->pr->lv), потомками new становятся левый и правый потомки удаляемого элемента, родитель удаляемого теперь ссылается на new.
 в конце всегда освобождаем память, замимаемую удаляемым элеменом.
 
 То есть, если у удаляемого элемента есть левое поддерево, то находим в нем самый правый элемент, убираем его из дерева, и переносим на место удаляемого, освобождая память, занятую удаляемым.

б) Заведем структуру, в которой будем хранить:
 - указатель на удаляемый элемент (адрес в памяти, по которому лежит сруктура, описывающая удаляемый элемент);
 - указатель на поле, внутри родительского его элемента в дереве, хранящее указатель на удаляемый элемент
 --- если удаляется корень, то это адрес ячейки памяти, в которой хранится указатель на корень дерева (т.е., той, которая объявлена как struct Elem * root в примере выше);
 --- или если удяляется элемент, имеющий родителя, то это адрес ячейки памяти внутри структуры, описывающей родительский элемент, в которой хранится указатель на удаляемый элемент (т.е., например, адрес поля parent->lv в случая если del_elem->val < patent->val).
 - указатель на самый правый элемент левого поддерева;
 (опционально) - указатель на родителя самого правого элемента или указатель на поле внутри родителя самого правого элемента, содержащее указатель на самый правый элемент левого поддерева.
 
Комментарий: т.е., заводим переменную struct Elem ** field_in_parent - которая будет указателем на то поле внутри родителя (структура parent) удаляемого элемента (структура del_elem), которое мы правим (т.е., указателем на указатель на удаляемый элемент). Тогда, если один раз уже поняли, что del_elem это parent->lv, записали в field_in_parent = &(parent->lv); то когда доходит дело до того, чтобы записать заменить удаляемый элемент другим элементом дерева (структура new_elem), в parent->lv = new_elem; не нужно опять проверять, был ли он левым или правым потомком, а достаточно сказать *field_in_parent = new_elem; (разыменование). Или, другой пример, изначально сделать field_in_parent = &root; и если выяснится, что удалять надо именно корневой элемент, то это можно будет сделать просто *field_in_parent = NULL. То есть, достаточно один раз обнаружить ячейку памяти (внутри того элемента дерева, который является родителем удаляемого), в которой лежит адрес удаляемого элемента, запомнить адрес этой ячейки (тот самый field_in_parent), забыть про родительский элемент, и когда, будем делать замену элементов, просто обратиться к этой ячейке по запомненному указателю.

в) Будем передавать указатель на эту новыю структуру в функции, тем самым позволим им к ней обращаться и менять ее поля.
Вспомните про scanf("...", &n); в случае, если хочется из функции вернуть больше чем одну переменную.

г) Функции (в большинстве своем) будут возвращать не указатели, а коды ошибок (0 - успех, все остальные цифры - различные ошибки и случаи).

д) Логика: 
- сначала найти все необходимые адреса;
- выполнить подмену;
- освободить память.


Задача 1. "CPU emulator"

Программа на Си.

В цикле на каждом шаге: пользователь вводит ассемблерную команду, программа печатает значения всех 4х регистров.

Регистры:

eax, ebx, ecx, edx

(то есть, нужны 4 переменные типа int) (удобно, например, сделать массив и обращаться к его элементам по индексу, или создать структуру и обращаться к полям по указателям, а индекс/указатель вычислять исходя из считанного имени регистра)

Команды:

mov, add, sub и выход (можете назвать его ret, 0, и т.д.)

Упрощение: Первый аргумент команды - всегда регистр, второй - имя регистра или число.

Возможные команды (можно обозначать регистры просто как a, b, c, d вместо полных названий):

mov eax, 15

mov eax, ebx

add ecx, edx

sub edx, 7

Считаем, что все цифры вводятся и выводятся в десятичной системе счисления.

Пример:

Ввод: mov eax, 2

Вывод: 2 0 0 0

Ввод: mov ebx, 5

Вывод: 2 5 0 0

Ввод: add eax, 1

Вывод: 3 5 0 0

Ввод: sub ebx, eax

Вывод: 3 2 0 0

Ввод: add edx, -1

Вывод: 3 2 0 -1

Ввод: ret

Выход из программы

Задача 2. Контест "Встроенный ассемблер x86 и x86_64" Полностью прорешать контест "Встроенный ассемблер x86 и x86_64" на http://judge.mipt.ru/arch.html

Задача 3. Asm read/write

Программа на Ассемблере.

Считать строку (длинной 100 символов) - все заглавные буквы сделать маленькими и наоборот. Другие символы изменяться не должны. Например, если в строке были числа - они должны остаться неизменными.

Задача 4. Шахматы

Программа на Ассемблере.

Написать программу, которая запишет в файл (если с файлом не получается, то хотя бы выведет на экран) шахматную доску 8x8 (можете ничего не считывать, только печатать).

Возможно, чтобы увидеть результат (если файл не откроется, или будет казаться пустым - это будет зависеть от того, как вы его создавали), придется изменить права доступа к этому вновь созданному файлу. Для этого (в Linux OS) поможет команда chmod.

chmod +r 1.txt - чтобы можно было читать из файла,

chmod +w 1.txt - чтобы можно было писать в файл,

chmod +x 1.txt - чтобы можно было исполнять файл

1.txt - имя файла.

Можно смотреть на https://github.com/mkudinova/Asm/blob/main/Open-write-close_in_Asm и https://github.com/mkudinova/Asm/blob/main/Open-read-write%20in%20C

Задача 5. Контест "NASM x86_64" На http://judge.mipt.ru/arch.html. Нужно решить хотя бы половину. Вторая половина будет засчитываться как еще одна задача. Можно использовать код с https://github.com/mkudinova/Asm/blob/main/printf

Задача 6. Hack a.out file

Программа на Си.

Дано: бинарный исполняемый файл, который запускаясь, выводит на экран Строку 1. (Т.е., пишите на Си "Hello world!", компилируете, получаете a.out (или 1.exe, и т.д. зависит от Вашей ОС) - и именно на него натравливаете свою программу.) Строка 1 - заранее определена.

Надо: написать на Си программу, которая получив (через параметры командной строки) имя бинарного исполняемого файла (a.out, из "Дано"), изменит этот бинарный файл так, чтобы выводилась другая Строка 2 - "Sapere aude!".

Важно, чтобы длины обеих строк совпадали.

Вам понадобится: работа с файлами (открыть, чтение, запись), строками и аргументами командной строки.

Ваша программа:

открывает файл, полученный в качестве аргумента командной строки,

находит в нем нужную Строку 1,

заменяет ее на Строку 2,

аккуратно все закрывает.

Измененный файл a.out должен запускаться и выводить "Sapere aude!" вместо "Hello world!".

Можно использовать пример из https://github.com/mkudinova/Asm/blob/main/Open-read-write%20in%20C , но лучше использовать не системные вызовы Linux (как в этом примере), а обычные библиотечные функции Си (например, любые из fopen, fclose, fread, fwrite, fprintf, fscanf, fgetc, fputc, fgetpos, ftell, fsetpos, fseek, rewind и т.д.; подробности покажет "man 3 имя_функции", русский вариант, например, тут https://www.opennet.ru/man.shtml?topic=fseek).

Задача 7. Hack a function

Программа на Си.

Надо: написать программу на Си, в которой есть 2 "честные" функции и функция "хакер":

honest_func_1() - делает что-то, и печатает Строку 1, например, "It's over, Anakin! I have the high ground!";

honest_func_2() - делает что-то, и печатает Строку 2, например, "You underestimate my power!".

hacker_func() - делает так, чтобы все вызовы honest_func_1() теперь перенаправлялись на honest_func_2().

Например, hacker_func() может вставить в начало тела honest_func_1() безусловный jump на адрес honest_func_2().

Вам понадобится:

найти адреса обеих функций (чтобы знать, где подменять код),

узнать (заранее) машинный код необходимых Вам ассемблерных инструкций (чтобы знать, на что подменять),

системный вызов mprotect() (для Linux OS), чтобы при попытке подмены кода функции (т.е., в момент записи этих ассемблерных инструкций в начало honest_func_1()) все не падало с Segmentation fault,

знания о порядке хранения байт в памяти (little-endian),

знания о размере страниц памяти (можете считать 0x1000 или честно вызвать sysconf(_SC_PAGE_SIZE) - для корректного вызова mprotect()),

Желательно использовать дебаггер (не обязательно, но с ним проще).

Пример изменения прав доступа к странице памяти,

size_t page_size = sysconf(_SC_PAGE_SIZE);

res = mprotect(base, page_size, PROT_READ | PROT_WRITE | PROT_EXEC);

// https://man7.org/linux/man-pages/man2/mprotect.2.html // https://shanetully.com/2013/12/writing-a-self-mutating-x86_64-c-program/ // https://stackoverflow.com/questions/7447013/how-to-write-self-modifying-code-in-c

НЕ ЗАБЫВАЙТЕ:

разбивать код на функции (т.е., hacker_func() НЕ НАДО писать сплошным текстом, пусть она вызывает 2-3 вспомогательные, написанные Вами, функции);

обработку ошибок (по меньшей мере для библиотечных функций);

main, который наглядно продемонстрирует, что Вы все сделали верно.

Задача 8. Локальные переменные

На Ассемблере (x64) написать простую программу: из main зовется функция func(), у которой есть 3 локальные переменные, и которая на Си выглядела бы как:

int func(){ int a, b, c; a=7; b=8; c=a+b; return c; }
